//
// nekRS User Defined File
//
#include "RANSktau.hpp"
#include "RANSktauBuo.hpp"
#include "tavg.hpp"

static dfloat rho, mueLam;
static int nAvgFields;

#ifdef __okl__

#include "cav.oudf"

#endif

void userf(dfloat time)
{
  mesh_t *mesh = nrs->mesh;
  cds_t *cds = nrs->cds;
  /* RANSbuo::updateForce(o_FU); */
  ktauBuoForce(mesh->Nlocal, nrs->fieldOffset, cds->o_S, nrs->o_NLT);

}
void userq(dfloat time)
{
  mesh_t *mesh = nrs->mesh;
  cds_t *cds = nrs->cds;

  RANSktau::updateSourceTerms();

  RANSbuo::updateSourceTerms();
}

void uservp(dfloat time)
{
  mesh_t *mesh = nrs->mesh;
  cds_t *cds = nrs->cds;

  RANSktau::updateProperties();

  RANSbuo::updateProperties();
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
}

void UDF_Setup()
{
  nrs->userProperties = &uservp;
  nrs->userScalarSource = &userq;
  nrs->userVelocitySource = &userf;

  auto mesh = nrs->mesh;
  const auto ktauFieldStart = 1;

	//Initial Conditions
  std::vector<dfloat> U(mesh->dim * nrs->fieldOffset, 0.0);
  std::vector<dfloat> s0(mesh->Nlocal, 0.0);
  std::vector<dfloat> k(mesh->Nlocal, 0.0);
  std::vector<dfloat> tau(mesh->Nlocal, 0.0);

  if (platform->options.getArgs("RESTART FILE NAME").empty()) {
    auto cds = nrs->cds;
    for(int n = 0; n < mesh->Nlocal; n++) {
      U[n + 0 * nrs->fieldOffset] = 1;
      U[n + 1 * nrs->fieldOffset] = 0;
      U[n + 2 * nrs->fieldOffset] = 0;
      s0[n] = 0.0;
      k[n] = 0.01; 
      tau[n] = 0.1;
    }
    nrs->o_U.copyFrom(U.data(), U.size());
    nrs->cds->o_S.copyFrom(s0.data(), s0.size(), cds->fieldOffsetScan[0]); 
    nrs->cds->o_S.copyFrom(k.data(), k.size(), cds->fieldOffsetScan[ktauFieldStart]); 
    nrs->cds->o_S.copyFrom(tau.data(), tau.size(), cds->fieldOffsetScan[ktauFieldStart + 1]); 
  }

	//RANS Setup
  RANSktau::setup(ktauFieldStart);
	//Buoyancy Setup
  const dfloat Ri = 1.0;
  dfloat gvec[3] = {0.0, -1.0, 0.0};
  RANSbuo::setup(ktauFieldStart, Ri, gvec);

	//Wall temp Profile
  std::vector<double> t1in(nek::ptr<double>("tin"), nek::ptr<double>("tin") + mesh->Nlocal);
  nrs->o_usrwrk.resize(nrs->fieldOffset);
  nrs->o_usrwrk.copyFrom(t1in);

	//Averaging Setup
	std::vector< std::vector<deviceMemory<dfloat>> > tavgFields;

	deviceMemory<dfloat> o_u(nrs->o_U.slice(0 * nrs->fieldOffset , nrs->fieldOffset));
	deviceMemory<dfloat> o_v(nrs->o_U.slice(1 * nrs->fieldOffset , nrs->fieldOffset));
	deviceMemory<dfloat> o_w(nrs->o_U.slice(2 * nrs->fieldOffset , nrs->fieldOffset));

	deviceMemory<dfloat> o_temp(nrs->cds->o_S.slice(nrs->cds->fieldOffsetScan[0], nrs->cds->fieldOffset[0]));
	deviceMemory<dfloat> o_k(nrs->cds->o_S.slice(nrs->cds->fieldOffsetScan[ktauFieldStart], nrs->cds->fieldOffset[ktauFieldStart]));
	deviceMemory<dfloat> o_tau(nrs->cds->o_S.slice(nrs->cds->fieldOffsetScan[ktauFieldStart+1], nrs->cds->fieldOffset[ktauFieldStart+1]));

	tavgFields.push_back({o_u});
	tavgFields.push_back({o_v});
	tavgFields.push_back({o_w});
	tavgFields.push_back({o_temp});
	tavgFields.push_back({o_k});
	tavgFields.push_back({o_tau});
	nAvgFields = tavgFields.size();
	tavg::setup(nrs->fieldOffset, tavgFields);
}

void UDF_ExecuteStep(dfloat time, int tstep)
{
	tavg::run(time);
	if(nrs->lastStep){
		auto mesh = nrs->mesh;
		//For post-processing (plotting done in usr file)
		auto o_scratch = platform->o_memPool.reserve<dfloat>(6 * nrs->fieldOffset);
		auto o_U = platform->o_memPool.reserve<dfloat>(3 * nrs->fieldOffset);
		auto o_temp = platform->o_memPool.reserve<dfloat>(nrs->fieldOffset);

		//Get all avg fields
		double *tavgs = nek::ptr<double>("tavgs");
		tavg::o_avg().copyTo(o_scratch, nAvgFields * nrs->fieldOffset);

		for(int ifld = 0; ifld < nAvgFields; ifld++) {
			const auto offset = ifld*nekData.lelt*mesh->Np;
			o_scratch.copyTo(tavgs + offset,
										nrs->fieldOffset,
										ifld*nrs->fieldOffset);
		}

		//store avg velocity and temperature
		o_U.copyFrom(o_scratch, 3 * nrs->fieldOffset, 0, 0 * nrs->fieldOffset);
		o_temp.copyFrom(o_scratch, nrs->fieldOffset, 0, 3 * nrs->fieldOffset);

		double *gradT = nek::ptr<double>("gradT");
		nrs->gradientVolumeKernel(mesh->Nelements,
															mesh->o_vgeo,
															mesh->o_D,
															nrs->fieldOffset,
															o_temp,
															o_scratch);
		oogs::startFinish(o_scratch,
											nrs->NVfields,
											nrs->fieldOffset,
											ogsDfloat,
											ogsAdd,
											nrs->gsh);
		platform->linAlg->axmyVector(mesh->Nlocal,
																 nrs->fieldOffset,
																 0,
																 1.0,
																 mesh->o_invLMM,
																 o_scratch);
		for(int ifld = 0; ifld < 3; ifld++) {
			const auto offset = ifld*nekData.lelt*mesh->Np;
			o_scratch.copyTo(gradT + offset,
										nrs->fieldOffset,
										ifld*nrs->fieldOffset);
		}

		double *sij = nek::ptr<double>("sij");
		auto o_Sij = nrs->strainRate(o_U);
		o_Sij.copyTo(o_scratch, 6 * nrs->fieldOffset);
		for(int ifld = 0; ifld < 6; ifld++) {
			const auto offset = ifld*nekData.lelt*mesh->Np;
			o_scratch.copyTo(sij + offset,
										nrs->fieldOffset,
										ifld*nrs->fieldOffset);
		}


		nek::userchk();
	}
	if(nrs->isCheckpointStep){
		tavg::outfld(nrs->mesh);
	}
}
