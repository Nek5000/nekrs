#include "velRecycling.hpp"
#include "tavg.hpp"
//#include "nekAscent.hpp"
//#include "nekAdios.hpp"

static int NSLABS;
static int NELSLAB;
static int renderStep;
deviceMemory<dfloat> o_qcriterion;

#ifdef NEKRS_ADIOS_ENABLED
NekAdios *nekAdios;
#endif

#ifdef __okl__

#include "turbPipe.oudf"

#endif

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  platform->par->extract("casedata", "nslabs", NSLABS);
  platform->par->extract("casedata", "nelslab", NELSLAB);
  platform->par->extract("casedata", "renderstep", renderStep); // ascent
}

void UDF_Setup()
{
  auto nrs = dynamic_cast<nrs_t*>(platform->solver);
  auto mesh = nrs->meshV;
  const auto zLen = abs( 
              platform->linAlg->max(mesh->Nlocal, mesh->o_z, platform->comm.mpiComm) - 
              platform->linAlg->min(mesh->Nlocal, mesh->o_z, platform->comm.mpiComm)
            ); 

  // set IC
  if (platform->options.getArgs("RESTART FILE NAME").empty()) {
    auto rand = randomVector<dfloat>(mesh->Nlocal, -1.0, 1.0, true);

    for (int n = 0; n < mesh->Nlocal; n++) {
      const auto R = 0.5;

      const auto xr = mesh->x[n] / R;
      const auto yr = mesh->y[n] / R;
      const auto zo = 2 * M_PI * mesh->z[n] / zLen;

      auto rr = xr * xr + yr * yr;
      rr = (rr > 0) ? sqrt(rr) : 0.0;
      const auto th = atan2(mesh->y[n], mesh->x[n]);

      auto uz = 6/5. * (1 - pow(rr, 6));

      // add a wiggly shear layer near the wall
      const auto amp_z    = 0.35;  // Fraction of 2pi for z-based phase modification
      const auto freq_z   = 4.0;   // Number of wiggles in axial- (z-) direction
      const auto freq_t   = 9.0;   // Frequency of wiggles in azimuthal-direction
      const auto amp_clip = 0.2;   // Clipped amplitude
      const auto amp_tht  = 5.0;   //  Amplification factor for clipped sine function
      const auto blt      = 0.07;  // Fraction of boundary layer with momentum deficit

      const auto phase_z = amp_z * 2 * M_PI * sin(freq_z * zo);

      auto amp_sin = amp_tht * sin(freq_t * th + phase_z);
      if (amp_sin >  amp_clip) amp_sin =  amp_clip;
      if (amp_sin < -amp_clip) amp_sin = -amp_clip;
      if (rr > (1 - blt)) uz += amp_sin;

      nrs->U[n + 0 * nrs->fieldOffset] = 0.05 * pow(rand[n], 2);
      nrs->U[n + 1 * nrs->fieldOffset] = 0.1  * pow(rand[n], 3);
      nrs->U[n + 2 * nrs->fieldOffset] = uz + 0.01 * rand[n];

      nrs->cds->S[n] = 0;
    }
  }

  nrs->o_usrwrk.resize(nrs->NVfields * nrs->fieldOffset);

  // velocity recycling
  const dfloat uBulk = 1.0;
  const int bID = 1;
  const dfloat zRecycLayer = 0.25 * zLen;
#if 0
  // does not work with current mesh
  const hlong offset = NELSLAB * std::round(NSLABS * zRecycLayer / zLen);
  velRecycling::setup(nrs->o_usrwrk, offset, bID, uBulk);
#else
  velRecycling::setup(nrs->o_usrwrk, 0.0, 0.0, zRecycLayer, bID, uBulk);
#endif

  // remove recycling section from field output
  const auto subMeshElements = [&] ()
  {
    std::vector<int> elements;
    for(int e = 0; e < mesh->Nelements; e++) {
       auto zmaxLocal = std::numeric_limits<dfloat>::lowest();
       for(int i = 0; i < mesh->Np; i++) zmaxLocal = std::max(mesh->z[i + e * mesh->Np], zmaxLocal);
       if (zmaxLocal > zRecycLayer) elements.push_back(e);
    }
    return elements;
  }();
  fld::elementFilter.set(subMeshElements);

  {
    std::vector< std::vector<deviceMemory<dfloat>> > tavgFields;

    deviceMemory<dfloat> o_u(nrs->o_U.slice(0 * nrs->fieldOffset , nrs->fieldOffset));
    deviceMemory<dfloat> o_v(nrs->o_U.slice(1 * nrs->fieldOffset , nrs->fieldOffset));
    deviceMemory<dfloat> o_w(nrs->o_U.slice(2 * nrs->fieldOffset , nrs->fieldOffset));

    deviceMemory<dfloat> o_temp(nrs->cds->o_S.slice(0 * nrs->cds->fieldOffset[0], nrs->cds->fieldOffset[0]));

    tavgFields.push_back({o_u});
    tavgFields.push_back({o_v});
    tavgFields.push_back({o_w});
    tavgFields.push_back({o_temp});

    tavgFields.push_back({o_u, o_u});
    tavgFields.push_back({o_v, o_v});
    tavgFields.push_back({o_w, o_w});
    tavgFields.push_back({o_temp, o_temp});

    tavgFields.push_back({o_u, o_v});
    tavgFields.push_back({o_v, o_w});
    tavgFields.push_back({o_w, o_v});

    tavg::setup(nrs->fieldOffset, tavgFields);
  }

  o_qcriterion.resize(nrs->meshV->Nlocal);

#ifdef NEKRS_ASCENT_ENABLED 
  {
    auto cds = nrs->cds;
    auto meshV = nrs->meshV;
    auto meshT = (nrs->cds) ? cds->mesh[0] : meshV;

    nekAscent::addVectorField("velocity", nrs->o_U, meshV, nrs->fieldOffset);
    nekAscent::addScalarField("scalar00", cds->o_S.slice(cds->fieldOffsetScan[0]), meshT);
    nekAscent::addScalarField("Qcriterion", o_qcriterion, meshV);

    const int Nviz = 1.5 * mesh->N;
    const auto uniform = false;
    nekAscent::setup(nrs->_mesh, "ascent.yaml", Nviz, uniform);
  }
#endif

#ifdef NEKRS_ADIOS_ENABLED
  {
    const int Nviz = 1.5 * mesh->N;
    const auto uniform = true;
    nekAdios = new NekAdios(nrs->_mesh, "simdata"); // Nviz, uniform);

    auto meshV = nrs->meshV;
    auto meshT = (nrs->cds) ? nrs->cds->mesh[0] : meshV;
    auto cds = nrs->cds;

    nekAdios->addVectorField("velocity", nrs->o_U, meshV, nrs->fieldOffset);
    nekAdios->addScalarField("scalar00", cds->o_S.slice(cds->fieldOffsetScan[0]), meshT);
    nekAdios->addScalarField("Qcriterion", o_qcriterion, meshV);
  }
#endif
}

void UDF_ExecuteStep(double time, int tstep)
{
  auto nrs = dynamic_cast<nrs_t*>(platform->solver);
  mesh_t *mesh = nrs->meshV;

  if (tstep == 0) {
    nrs->writeCheckpoint(time, tstep); 
  }

  velRecycling::copy();
  if (nrs->timeStepConverged) {
    tavg::run(time);
  }

  auto computeQ = nrs->isCheckpointStep;
#ifdef NEKRS_ASCENT_ENABLED
  if (tstep % renderStep == 0) computeQ = 1;
#endif
  if (computeQ) {
    nrs->Qcriterion(nrs->o_U, o_qcriterion);
  }

  if (nrs->isCheckpointStep) {
    auto o_UZ = nrs->o_U + 2 * nrs->fieldOffset;
    const dfloat ubar =
        platform->linAlg->innerProd(mesh->Nlocal, o_UZ, mesh->o_Jw, platform->comm.mpiComm) / mesh->volume;
    if (platform->comm.mpiRank == 0) {
      printf(" uBulk: %g\n", ubar);
    }

#ifdef NEKRS_ADIOS_ENABLED 
    {
      nekAdios->write<float>(time, tstep);
      if (nrs->lastStep) nekAdios->close();
    }
#endif

    tavg::outfld();
  }

#ifdef NEKRS_ASCENT_ENABLED 
  if (tstep % renderStep == 0) {
    //std::vector<occa::memory> o_fldList;
    //o_fldList.push_back(o_qcriterion);
    //fld::write("qcrit", time, tstep, o_fldList, true, false, mesh->N, true);
    nekAscent::run(time, tstep);
  }
#endif
}
