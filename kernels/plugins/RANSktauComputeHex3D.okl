@kernel void RANSktauComputeHex3D(const dlong N,
                                  const dlong offset,
                                  const dfloat rho,
                                  const dfloat mue,
                                  @ restrict const dfloat *K,
                                  @ restrict const dfloat *TAU,
                                  @ restrict const dfloat *STMAG2,
                                  @ restrict const dfloat *OIOJSK,
                                  @ restrict const dfloat *XK,
                                  @ restrict const dfloat *XT,
                                  @ restrict const dfloat *XTQ,
                                  @ restrict dfloat *SRCDIAG,
                                  @ restrict dfloat *SRC)
{
  for (dlong n = 0; n < N; ++n; @tile(p_blockSize, @outer, @inner))
    if(n < N){
      const dfloat xk = XK[n];
      const dfloat xt = XT[n];
      const dfloat xtq = XTQ[n];

      const dfloat stMag2 = STMAG2[n];
      const dfloat OiOjSk = OIOJSK[n];

      const dfloat kk = K[n];
      const dfloat tau = TAU[n];

      dfloat itau = 0;
      if (tau > 0)
        itau = 1 / (tau + p_tiny);

      const dfloat mu_t = rho * p_alpinf_str * kk * tau;

      dfloat sigd = p_sigd_min;
      dfloat f_beta_str = 1.0;
      if (xk > 0) {
        const dfloat xk3 = xk * xk * tau * tau;
        sigd = p_sigd_max;
        f_beta_str = (1.0 + p_fb_c1st * xk3) / (1.0 + p_fb_c2st * xk3);
      }

      // compute source term for k
      const dfloat Y_k = rho * p_betainf_str * f_beta_str * itau;

      // compute source term for tau
      const dfloat x_w = fabs(OiOjSk) * (tau * tau * tau * p_ibetainf_str3);
      const dfloat f_b = (p_pope) ? (1.0 + p_fb_c1 * x_w) / (1.0 + p_fb_c2 * x_w) : 1.0;
      const dfloat Y_w = -rho * p_beta0 * f_b;
      const dfloat S_w0 = -rho * sigd *xk;
      const dfloat G_wp = rho * p_alp_inf * tau * 2.0 * stMag2;

      const dfloat tau_max = 8.0 * p_beta0 / 3.0;
      const dfloat S_tau = fmin(8.0 * mue * xtq, tau_max);
      const dfloat S_taup = 8.0 * rho * p_alpinf_str * kk * xtq * p_sigma_tau;	  

      const dfloat kSrc = fmin(mu_t * 2.0 * stMag2, 10.0 * Y_k * kk);
      const dfloat kDiag = Y_k;

      dfloat tauSrc = 0.0;
      dfloat tauDiag = 0.0;
      if(tau < p_tiny){
        tauSrc = -Y_w - S_tau;
        tauDiag = G_wp - S_w0 + S_taup;
      }
      else{
        tauSrc = -Y_w;
        tauDiag = G_wp - S_w0 + S_taup + S_tau * itau;
      }

      SRC[n + 0 * offset] = kSrc;
      SRC[n + 1 * offset] = tauSrc;
      SRCDIAG[n + 0 * offset] = kDiag;
      SRCDIAG[n + 1 * offset] = tauDiag;
    }
}
