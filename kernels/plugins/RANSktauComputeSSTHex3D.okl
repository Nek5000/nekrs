@kernel void RANSktauComputeSSTHex3D(const dlong N,
                                  const dlong offset,
                                  const dlong mid,
                                  const dfloat rho,
                                  const dfloat mue,
                                  @ restrict const dfloat *K,
                                  @ restrict const dfloat *TAU,
                                  @ restrict const dfloat *STMAG2,
                                  @ restrict const dfloat *XK,
                                  @ restrict const dfloat *XT,
                                  @ restrict const dfloat *XTQ,
                                  @ restrict const dfloat *DGRD,
                                  @ restrict const dfloat *YWD,
                                  @ restrict const dfloat *OMAG2,
                                  @ restrict dfloat *SRCDIAG,
                                  @ restrict dfloat *SRC)
{
  for (dlong n = 0; n < N; ++n; @tile(p_blockSize, @outer, @inner))
    if(n < N){
      const dfloat xk = XK[n];
      const dfloat xt = XT[n];
      const dfloat xtq = XTQ[n];

      const dfloat stMag2 = STMAG2[n];

      const dfloat kk = K[n];
      const dfloat tau = TAU[n];

      dfloat itau = 0;
      if (tau > 0)
        itau = 1 / (tau + p_tiny);

      const dfloat yw = YWD[n];
      dfloat f1 = 1.0;
      dfloat mu_t = 0.0;
      SSTBlendingFunc(rho, mue, kk, tau, stMag2, xk, yw, f1, mu_t);

      const dfloat mu_min = p_edd_free * mue;
      dfloat Rfact = 1.0;
      if(mu_t < mu_min && yw > p_ywlim) 
        Rfact = mu_t / mu_min;

      const dfloat f11 = 1.0 - f1;
      const dfloat beta = f1 * p_beta0_SST + f11 * p_beta2;
      const dfloat gamma = f1 * p_alp_inf_SST + f11 * p_gamma2;
      const dfloat sigom = f1 * p_sigma_tau + f11 * p_sigom2;

      dfloat Y_k = 0.0;

      if(mid == 0) {
        Y_k = rho * p_betainf_str * itau;
      }
      else {
        const dfloat cdes = f1 * p_cdes1 + f11 * p_cdes2;

        const dfloat k2 = sqrt(kk);
        const dfloat ransL = k2 * (tau + p_tiny) / p_betainf_str;
        const dlong ide = n / p_Np;
        const dfloat hmax = DGRD[ide];
        const dfloat xlesL = cdes * hmax;
        const dfloat xnueff = (mue + mu_t) / rho;
        const dfloat omag2 = OMAG2[n];
        const dfloat sqStOm = sqrt(stMag2 + omag2);
        const dfloat ykap = p_vkappa * yw;
        const dfloat ykap2 = ykap * ykap;
        const dfloat denom_rd = ykap2 * sqStOm;
        dfloat rd = 0.0;
        if(denom_rd > p_tiny) rd = xnueff / denom_rd;
        const dfloat cd12 = pow(p_cd1 * rd, p_cd2);
        const dfloat fd = 1.0 - tanh(cd12);
        const dfloat ddesL = ransL - fd * fmax(0.0, ransL - xlesL);

        if(ddesL > 0.0) Y_k = rho * k2 / ddesL;
      }

      const dfloat Y_w = -rho * beta * Rfact;
      const dfloat S_w0 = -2.0 * rho * p_sigom2 * f11 * xk * Rfact;
      const dfloat G_wp = rho * gamma * tau * 2.0 * stMag2 * Rfact;

      const dfloat tau_max = 8.0 * beta / 3.0;
      const dfloat S_tau = fmin(8.0 * mue * xtq * Rfact, tau_max);
      const dfloat S_taup = 8.0 * rho * kk * xtq * sigom * Rfact;

      const dfloat kSrc = fmin(mu_t * 2.0 * stMag2, 10.0 * Y_k * kk);
      const dfloat kDiag = Y_k;

      dfloat tauSrc = 0.0;
      dfloat tauDiag = 0.0;
      if(tau < p_tiny){
        tauSrc = -Y_w - S_tau;
        tauDiag = G_wp - S_w0 + S_taup;
      }
      else{
        tauSrc = -Y_w;
        tauDiag = G_wp - S_w0 + S_taup + S_tau * itau;
      }

      SRC[n + 0 * offset] = kSrc;
      SRC[n + 1 * offset] = tauSrc;
      SRCDIAG[n + 0 * offset] = kDiag;
      SRCDIAG[n + 1 * offset] = tauDiag;
    }
}
